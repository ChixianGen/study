classloader类加载三个阶段：
1、装载（Load）：找到class文件并把这个文件包含的字节码加载到内存；

2、链接（Link）：字节码验证，class类数据结构分析以及相应内存分配，符号表的链接；
    a、校验（Verify）：对二进制字节码的格式进行校验，以确保格式正确、行为正确；
           1).文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。
           2).元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。
           3).字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。
           4).符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。

    b、准备（Prepare）:准备类中定义的字段、方法和实现接口所必需的数据结构。比如会为类中的静态变量赋默认值(int:0, reference:null, char:’\u0000’)。
                  准备阶段正式为类变量分配内存并设置初始值。这里的初始值并不是初始化的值，而是数据类型的默认零值。
                  这里提到的类变量是被static修饰的变量，而不是实例变量。关于准备阶段为类变量设置零值的唯一例外就是当这个类变量同时也被final修饰，
                  那么在编译时，就会直接为这个常量赋上目标值。
                  如：
                  pirvate static int size = 12;
                  那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值;

    c、解析（Resolve）:虚拟机将常量池内的符号引用替换为直接引用的过程。装入类所引用的其他所有类，虚拟机将常量池中的符号引用替换为直接引用。
                可以用许多方式引用类：超类、接口、字段、方法签名、方法中使用的本地变量

3、初始化（Initializ）：类中静态属性初始化赋值以及静态代码块的执行；



类的初始化：
1、主动使用：
    1)、new关键字；
    2)、访问某个类或接口的静态变量，或者对该静态变量进行赋值操作；如果变量【final】修饰的除外；
    3)、调用静态方法；包括【final】修饰的方法；
    4)、反射某个类；Class.forName(...)
    5)、初始化一个子类；
    6)、启动类；比如命令--> java HelloWorld

2、被动使用；



类的加载，简单来说就是将class文件中的二进制数据读取到内存中，将其放在方法区，然后在堆区创建一个java.lang.Class对象，用来封装在方法区的数据结构；