### Thread.sleep()方法是会让出时间片的。
### Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。
***
#### 接下来谈下yield和sleep的区别：
虽然两者都是静态方法，也同样是让自己放弃CPU的执行权，让给其他线程机会，但是它们之间还是有区别滴！
* sleep让给别人机会以后，自己处于阻塞状态，而yield处于就绪状态
* sleep方法使用时要抛出异常，而yield什么都不做。
* sleep会不考虑优先级的给其他线程机会，而yield是考虑同等优先级地给予其他线程机会！
（可以类比为：一般情况下，同班同学才能让给他“扫把”使用，如果是外校的人，那么只有等我睡着了，才会有让让他得到“扫把”的可能，原因是：优先级不一样）
* sleep的可移植性比yield好，不能靠yield来提高程序的并发性能，它的唯一用途是在测试期间人为地提高程序的并发性能，以帮助发现一些隐藏的错误。

***
### Thread.sleep()和 Object.wait() 有什么区别?
* sleep来自Thread类，和wait来自Object类；
* sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以进入同步控制块或者方法。
* wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。
* notify和notifyAll都不会立即释放锁资源；
***
高并发程序的要求：
1. 原子性：
    ```
    synchronized (this) {
         a=1;
         b=2;
     }
     一个线程观察另外一个线程执行上面的代码，只能看到a、b都被赋值成功结果，或者a、b都尚未被赋值的结果。
    ```
2. 有序性：
    > java的有序性跟线程相关。如果在线程内部观察，会发现当前线程的一切操作都是有序的。
        如果在线程的外部来观察的话，会发现线程的所有操作都是无序的。
        因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。
        volatile和synchronized可以保证指令不进行重排序，从而保证程序的有序性。
3. [可见性](https://share.weiyun.com/5ONfFpi)
    - 总线加锁（锁力度大，性能太低，已废弃）：
        > CPU(执行线程)从主内存中读取数据到高速工作缓存中，会再总线对当前数据加锁，这样其他CPU(线程)就无法读写该数据，直到
        持有锁的CPU释放锁；
    - MESI缓存一致性协议（volatile关键字）：
        > - 多个CPU(多线程)从内存中读取同一份数据到各自的工作缓存，当其中某个线程修改了自己缓存中的数据，该数据会马上被同步回
        主内存中，其他线程通过[总线嗅探机制]可以感知数据的变化，从而使自己缓存中的该数据失效；
        > - 底层主要是通过汇编后加上Lock前缀指令，细粒度同步：当一个[线程共享变量(例：static变量)]被一个线程修改了值后，需要回写
        主内存；通过数据总线时，总线的嗅探机制会让其他线程的工作缓存中当前变量的副本失效，而其他线程需要重新从主内存中获取变量值；（跟上一条一个意思，个人的理解）
        
        汇编后Lock指令的作用：
        - 会将修改了变量的那个线程的工作缓存中的值[立即]写入主内存中；
        - 写之前[加锁]，写入主内存成功后[解锁]；
        - 让其他线程的工作缓存中该变量值数据失效；

    > synchronized和final也能实现可见性。
    > - synchronized保证unlock之前必须先把变量刷新回主内存。
    > - final修饰的字段在构造器中一旦完成初始化，并且构造器没有this逸出，那么其他线程就能看到final字段的值。

> 注：volatile关键字仅满足了--> 有序性（禁止重排序）、可见性（内存）；保证原子性需要借助synchronized锁机制；
---
### synchronized
> synchronized方法或代码块中，如果发生异常，则当前的执行线程会释放锁资源；解决方案：try-catch处理；